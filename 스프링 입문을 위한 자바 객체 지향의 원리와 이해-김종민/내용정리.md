## 1. 사람을 사랑한 기술

#### 1-1. 신기술은 이전 기술의 어깨를 딛고

    - 신기술은 갑자기 하늘에서 뚝 떨어지는 것이 아니라 이전 기술의 어깨를 디딤돌 삼아 이전 기술을 거름 삼아 새로운 처학과 기법을 더해 나타난다.

    - 스프링은 과거에서 현재까지의 프로그래밍 발전사

    - 스프링을 학습하려면 이전 기술들을 마스터 해야 하는가? -> NO! 그저 이전 기술의 어깨를 딛기만 하면 됨.

#### 1-2. 기계어에서 객체 지향 프로그래밍 언어로

    - 프로그래밍 언어의 역사는 기계어에서 객체 지향 프로그래밍 언어로 진일보하게 발전해왔다.

    - 제일 초기의 프로그래밍 언어인 기계어는 0과 1로 프로그램을 작성했다. 최초의 프로그래머들은 키보드, 모니터, 마우스 없이 프로그래밍 한 것은 덤.

    - 어셈블리어: "기계어의 명령들을 일상 용어로 표현하고 이걸 기계가 알 수 있는 기계어로 번역하게 하면 어떨까?" 라는 관점에서 만들 최초의 인간 지향적 언어. 기계어 명령어와 일상 용어를 일대일로 매칭되는 코드표(어셈블리)를 생성. 허나 CPU 별로 기계어가 다르기 때문에 CPU 마다 어셈블리어도 달랐다. 게다가 각 어셈블리어들은 호환성이 없었기 때문에 각각의 어셈블리어를 별도로 학습해야하는 불편함도 있었다.

    - C 언어: C언어의 등장으로 소스 파일을 단 하나만 만들면 됨(싱글 소스). 기존에는 프로그램의 소스 파일을 각 기계의 종류만큼 만들어야 했음. C언어의 등장으로 하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일만 하면 각 기계에 맞는 기계어 목적 파일이 만들어짐.

    - C++: C 언어에 객체 지향의 개념을 도입한 언어.

    - JAVA: 진정한 객체 지향 언어.  컴파일러를 기종별로 따로 구매해두지 않아도 됨. 자바 소스를 다른 기종의 컴퓨터에서 실행하기 위해 목적 파일인 오브젝트 파일 + 각 기종의 컴퓨터 운영체제에 해당하는 JRE가 설치되어 있으면 됨.

    - 객체 지향 방법론은 이름 그대로 방법론이며, 객체 지향을 기반으로 개발된 C++, JAVA, Spring 등을 알기 위해서는 객체 지향에 대한 깊은 이해는 필수 불가결하다

## 2. 자바와 절차적/ 구조적 프로그래밍

#### 2-1. 자바 프로그램의 객발과 구동

    - 현실 세계예서 컴퓨터를 구동하기 위해서는 물리적 컴푸터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요함. + 소프트웨어를 개발할 수 있는 개발도구

    - 소프트웨어 개발 도구 -> JDK - 자바 개발 도구(JVM용 소프트웨어 개발 도구)

    - 운영체제 -> JRE - 자바 실행 환경(JVM용 OS)

    - 하드웨어(물리적 컴퓨터) -> JVM(Java Virtual Machine) 자바 가상 기계. 가상의 컴퓨터

    - 프로그램이 메모리를 사용하는 방식 -> 코드 실행 영역과 데이터 저장 영역으로 구성

    - 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용.(스태틱 영역, 스택 영역, 힙  영역)

![image](./image.png)

#### 2-2. 다시 보는 main() 메서드: 메서드 스택 프레임

    - 자바에서 main 메서드안의 System.out.println을 실행할 때, 메모리에서는 무슨 일이 일어날까?

    - JRE는 프로그램 안에 main 메서드가 있는지 확인한다.

    - main 메서드의 존재가 확인되면, JRE는 프로그램 실행을 위한 사전 준비에 착수

    - JVM을 부팅하여 목적 파일을 JVM에서 실행.

    - println을 실행하기 위해 java.lang 패키지를 메모리의 스태틱 영역에 가져다 놓음.(System.out.println 메서드를 실행하기 위한 사전 준비)

    - 개발자가 작성한 모든 클래스와 패키지를 스태틱 영역에 가져다 놓음

    - main 메서드의 스택 프레임이 스택 메모리 영역에 할당됨.

    - 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보해서 변수 공간을 할당한다.

    - 닫는 중괄호를 만나면 스택 프레임이 소멸된다.

    - main 메서드가 끝나면 JRE는 JVM을 종료하고, JRE 자체도 운영체제 상의 메모리에서 사라짐

#### 2-3. 전역 변수와 메모리

    - 두 메서드 사이에 값을 공유하기 위해서 전역 변수를 사용함.

    - 자바 코드에서 static 키워드가 붙은 변수는 메모리에서 스태틱 영역에 변수 공간이 할당된다.

    - 따라서 스택 메모리의 스택 프레임 안에서 스태틱 영역에 존재하는 변수 값들을 전역적으로 가져다가 쓸 수 있다.

    - 프로젝트와 코드의 규모가 커지면서 여러 메서드에서 전역 변수의 값을 변경하기 시작하면 메모리로 전역 변수를 추적하지 않는 이상, 전역 변수에 저장돼 있는 값을 파악하기 쉽지 않기 때문에 전역 변수의 사용을 지양한다.

    - 따라서 전역 변수의 사용은 전역적으로 사용하는 변하지 않는 값(상수)를 사용할 때, 주로 사용하는 것이 바람직하다(ex: Math 클래스의 PI 값)

#### 2-4. 멀티 스레드 / 멀티 프로세스의 이해

    - 멀티 스레드: 메모리의 스택 영역을 스레드 개수만큼 분할해서 사용하는 것. 하나의 메모리 구조 안에서 스택 영역만 분할한 것이기 때문에 하나의 스레드에서 다른 스레드의 스택 영역에ㅅ는 접근할 수 없지만, 스태틱 영영과 힙 영역은 공유하는 구조. 따라서 멀티 프로세스 대비 메모리를 적게 사용할 수 있는 구조

    - 멀티 프로세스: 다수의 데이터 저장 영역, 즉 다수의 메모리(메모리 구조 그 자체를 더 갖는 구조)를 갖는 구조. 각 프로세스가 각자의 메모리 구조를 갖고 있기 때문에 서로 참조할 수 없다.

#### 2-5. 정리

    - 스태틱 메모리: 클래스의 놀이터

    - 스택 메모리: 메서드의 놀이터

    - 힙 메모리: 객체의 놀이터

## 3. 자바와 객체 지향

#### 3-1. 객체 지향은 인간 지향이다.

    - 객체 지형은 현실 세계를 반영한다. 그 증거는? -> "객체"

    - 기존 절차적/ 구조적 프로그래밍 언어에서 가장 중요한 것은 "함수" -> 함수는 코드를 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 뜻. D&C(Divide And Conquer) == 분할 정복. "천 리 길도 한 걸음부터"와 비슷한 맥락. 몇 천, 몇 만 라인의 명령어를 논리적인 단위로 나누어서 블록화해서 작성하자. 이런 논리적인 단위의 블록 -> 함수

    - 객체 지향 프로그래밍: 우주 만물은 객체들의 합이라는 거셍서부터 시작. 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍하는 방법. 따라서 직관적이다.

    - 객체 지향을 이해하기 위한 큰 그림
        - 세상에 존재하는 모든 것은 사물, 즉, 객체다.
        - 각각의 사물은 고유하다
        - 사물은 속성을 갖는다.
        - 사물은 행위를 한다

    - 사물을 하나하나 이해하기 보다는 사물을 분류(class)해서 이해하는 것이 인간의 인지법.
        - 직립보행을 하며 말을 하는 존재를 사람이라고 분류한다.
        - 연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류한다.
        - 밤하늘에 반짝이는 사물들을 별이라고 분류한다.

    - 클래스 vs 객체
        - 클래스는 객체들의 공통 특징들을 모아서 정의한 것.
        - 사람이라는 클래스가 가지는 속성으로는 나이, 몸무게, 키 등이 있으며
        이를 property라고 한다.
        - 사람이라는 클래스가 가지는 행위로는 먹다, 자다, 울다 등이 있는데,
        이를 method라고 한다.
        - 객체는 클래스의 특징을 가지고 있는 하나의 고유한 사물이다
        - 사람 클래스의 특징을 모두 가지는 "김종민"이라는 객체가 있다고 가정해보자.
        - 김종민 씨는 사람 클래스를 가지는 객체이기에 김종민씨 고유의 나이, 몸무게,
        키 속성을 가진다. 또한 김종민씨 고유의 메서드(먹고, 자고, 우는 행위 등)을
        가질 것이다.

#### 3-2. 객체 지향의 4대 특성 - 캡! 상추다

    - 객체 지향의 4대 특성: 캡! 상추다
    - 캡 -> 캡슗화(Encapsulation): 정보 은닉
    - 상 -> 상속(Inheritance): 재사용
    - 추 -> 추상화(Abstraction): 모델링
    - 다 -> 다형성(Polymorphism): 사용 편의

#### 3-3. 클래스 vs 객체 == 붕어빵틀 vs 붕어빵 -> 사실 잘못된 비유다?

    - 객체 지향을 배울 때, 가장 흔한 예로 드는 것이 바로 클래스와 객체의 관계를 붕어빵틀과 붕어빵이다.

```java
클래스 객체명 = new 클래스();
```

    - 그런데 이는 사실 정확한 비유가 아니다. 추가로 예시를 들기 위해 붕어빵틀을 생산하는 금형 기계가 있다고 하자. 그럼 붕어빵틀이 붕어빵을 찍어내서 클래스라고 한다면, 같은 논리로 금형 기계는 붕어빵틀을 찍어내는 클래스가 된다. 이를 코드로 나타내면

```java
금형기계 붕어빵틀 = new 금형기계();
```

    - 위 코드를 인간의 말로 번역해보면 "새로운 금형기계를 하나 만들었더니 붕어빵틀이다"이다. 이는 절대 금형기계와 붕어빵틀이 클래스와 객체 관계가 아니듯이 붕어빵틀과 붕어빵도 클래스와 객체 관계가 아닌 것이다.

    - 그렇다면 객체와 클래스를 가장 잘 구분할 수 있는 기준은 무엇일까? 다음 질문의 답을 해보자

    - 사람의 나이는 몇 살인가?
    - 김연아의 나이는 몇 살인가?
    - 뽀로로의 나이는 몇 살인가?
    - 펭귄의 나이는 몇 살인가?

    - 사람과 펭귄의 나이를 맞출 수는 없다. 왜녀하면 클래스는 분류에 대한 개념일 뿐, 실체가 아니기 때문이다

    - 객체는 실체이다.

    - 따라서 붕어빵틀과 붕어빵이라는 잘못된 예시(왜냐하면 붕어빵틀은 분명히 실체가 존재하기 때문?) 대신 올바른 메타포는 다음과 같다

```java.. ㅊ
ㅕ7
클래스 : 객체 = 펭궨 : 뽀로로 = 사람 : 김연아
```

    클래스: 분류에 대한 개념. 실체가 아님
    객체: 클래스의 특징을 가지고 있는 확실한 실체 그 자체

#### 3-4. 추상화(Abstraction) == 모델링

    - 객체 지향에서의 추상화: 공통 특성 / 공통 속성 추출

    - 객체 지향에서의 추상화는 곧 모델링이다.

    - 사람이라는 클래스를 설계한다고 가정해보자
        - 사람 클래스의 속성으로는 시력, 몸무게, 혈액형, 키, 나이, 직업, 취미
        등등의 속성을 가진다.
        - 먹다, 자다, 일하다, 침 뱉다, 울다 등등의 동사로 표현되는 특성을
        기능/ 행위라고 한다. 이러한 기능 / 행위를 메서드라고 한다.

    - IT 용어에서의 추상화: 구체적인 것을 분해해서 관심 영역(애플리케이션 경계.Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링

    - 추상화의 대표적인 예시: 지구 - 지구본의 관계. 지구본에 지구의 모든 요소를 표현할 수는 없지만, 지구의 대표 속성인 바다, 대륙 등을 이용하여 지구의 특성을 추상화 하였다.

    - 객체 지향에서 추상화의 결과는 클래스이다.

    - 추상화는 상속, 인터페이스, 다형성을 통해 구현될 수 있다.

    - 추상화 = 모델링 = 자바의 class 키워드

#### 3-5. 상속: 재사용 + 확장

    - 객체 지향에서의 상속을 현실에서의 상속(Inheritance)의 개념으로 이해하면 안된다.

![image](<./inheritance(1).jpeg>) - 상속에 대한 잘못된 예시
<br><br><br><br>

![image](<./inheritance(2).jpeg>) - 상속에 대한 올바른 예시

    - 객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래서에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미

    - 상위 클래스(슈퍼 클래스)로 갈수록 추상화, 일반화 됐다라고 말할 수 있으며, 하위 클래스(서브 클래스)로 갈수록 구체화, 특수화 됐다라고 말할 수 있다.

    - 상속 관계에서 "하위 클래스는 상위 클래스다"라는 명제는 반드시 만족해야 하는 명제이다.

    - 객체를 생성할 때, 객체 참조 변수명은 객체스럽게, 클래스명은 클래스명답게 작명하는 습관이 중요하다.

    - ex: 조류 bird = new 조류(); -> 매우 좋지 않은 코드
        - 왜냐하면 "bird"에 해당하는 부분은 객체 참조 변수인데, 객체 참조 변수는 그
        자체로 하나의 개체이자 유일무이한 것이기 때문이다. bird의 나이는?
        bird의 무게는? bird를 실체를 가지는 하나의 객체로 만들어줬음에도 불구하고
        해당 질문에 대한 답을 할 수가 없다.
        따라서 객체를 만들 때에는 객체명을 유일무이하게 구분 가능하게 지어야한다.

    - 상속 관계를 표현하는 문구는 "is a"보다는 "is a kind of"라는 문구가 더 정확하다.

    - 객체 지향의 상속은 상위 클래스의 특성을 재사용 하는 것

    - 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것

    - 객체 지향의 상속은 is kind of 관계를 만족해야 함

    - 자바에서의 인터페이스
        - 인터페이스: 구현 클래스 is able to 인터페이스
        - 구현 클래스는 인터페이스 할 수 있다
        - ex: 고래는 헤엄칠 수 있다.

    - 상위 클래스는 하위 클래스에게 특성(속성 + 메서드)를 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라는 기능을 구현하도록 강제하도록 한다.

    - 상위 클래스는 하위 클래스에서 물려줄 특성이 풍부할수로 좋다.

    - 인터페이스는 구현을 강제할 메서드가 적을수록 좋다.

#### 3-6. 다형성: 상속 편의성

    - 기본적으로 객체 지향에서의 다형성: 오버라이딩(overriding), 오버로딩(overloading)

    - 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
    - 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

    - 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고, 이러한 다형성이 개발자가 프로그램을 작성할 때 사용 편의성을 줌

#### 3-7. 캡슐화: 정보 은닉

    - 접근 제어자: private, default, protected, public

    - 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후, 객체 잠조 변수를 이용해 접근해야 한다.

    - 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장(일관된 형식으로 접근 및 메모리의 물리적 접근에 따른 이유)

    - protected에 대한 오해와 진실: protected는 같은 패키지 내의 모든 클래스에서 접근이 가능하다? -> No!

    -aaa.jar 파일 안에 packageOne이라는 패키지가 있고, bbb.jar 파일 안에도 packageOne이라는 같은 이름을 가진 패키지가 있다고 가정해보자.

    - bbb.jar 파일 내부의 packageOne 패키지 내 클래스나 객체에서 aaa.jar 파일 내부의 packageOne 패키지 내 클래스나 객체가 가진 public 멤버 뿐만 아니라 default, protected 멤버에 자유롭게 접근할 수 있다...

## 4. 자바와 확장한 객체 지향

## 5. 객체지향 설계 5원칙 - SOLID

## 6. 스프링이 사랑한 디자인 패턴

## 7. 스프링 삼각형과 설정 정보

## 8. 스프링 MVC를 이용한 게시판 구축

## 9. 자바 8 함다와 인터페이스 스펙 변화
