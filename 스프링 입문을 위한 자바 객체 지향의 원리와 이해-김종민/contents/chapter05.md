## 5. 객체지향 설계 5원칙 - SOLID

- 설계 원칙이란?
  - 음식을 만들 때, 레시피가 있듯이 소프트웨어를 만들 때, 긴 세월동안 수많은 시행착오와 베스트 프랙티스 속에서 객체 지향 설계의 정수가 탄생했는데, 이 개념이 바로 SOLID이다.
  - SOLID란 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙
  - SOLID 원칙은 OOP를 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에서 적용될 수 있음
  - SOLID는 우리가 만드는 제품, 즉 소프트웨어에 녹여내야 하는 개념

#### 5-1. SRP - 단일 책임 원칙

    - "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." -로버트.C.마틴

    - 하나의 클래스는 반드시 하나의 역할을 수행해야 한다.

![image](<../assets/SRP(1).jpeg>) - 단일 책임 원칙을 지키지 않은 설계

    - ex: 남자라는 클래스와 남자 클래스에 의존하는 다양한 클래스가 있다(여자친구, 어머니, 직장상사, 소대장)고 생각해보자.

    - 남자 클래스는 여러 클래스가 의존하고 있기에 역할과 책임이 너무 많다. 만약 남자 클래스를 의존하고 있는 여자친구 클래스가 사라지거나 사양이 변경된다면, 그 영향은 남자 클래스를 의존하고 있는 다른 클래스(어머니, 직장상사, 소대장)에게까지 영향을 미친다.

    - 따라서 이런 경우에 역할(책임)을 분리하는 것이 단일 책임 원칙

![image](<../assets/SRP(2).jpeg>) - 단일 책임 원칙을 적용한 설계

    - 클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임을 갖게 한 설계

    - 데이터베이스 테이블 설계에서의 "정규화"도 단일 책임 원칙의 일종

#### 5-2. OCP - 개방 폐쇄 원칙

    - "소프트웨어 엔티티(클래스 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다" -로버트.C.마틴
    -> 의역: 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

    - ex: 운전자가 차를 마티즈에서 소나타로 바꿨다고 해서 기존에 운전하는 방법에 영향을 주지 말아야 한다. 즉, 자동차(클래스)의 입장에서는 자신의 확장에서는 개방돼 있고, 운전자의 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

    - ex: JDBC -> JDBC를 사용하는 클라이언트는 DB가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다. -> 데이터베이스 본인의 확장에는 열려있고, 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀있는 것.

#### 5-3. LSP: 리스코프 치환 원칙

    - "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." -로버트.C.마틴

    - LSP 원칙과 상속은 다음과 같은 조건을 만족해야 한다.
        - 하위 클래스 is a kind of 상위 클래스(하위 분류는 상위 분류의 한 종류다)
        - 구현 클래스 is able to 인터페이스(구현 분류는 인터페이스 할 수 있어야
        한다.)

    - 상위 클래스의 객체 참조 변수에는 하위 클래스의 인스턴스를 할당할 수 있어야 한다.
        - ex: 아버지 춘향이 = new 딸();
        -> "딸을 하나 낳아서 이름을 춘향이라 하였으며 아빠의 역할을 수행해라"
        -> 굉장히 이상한 문장이다. 춘향이는 아버지의 객체 참조 변수이기 때문에 아버지
        객체가 가진 행위(메서드)를 할 수 있어야 하는데, 춘향이가 아버지의 모든
        역할을 수행할 수는 없다. 따라는 LSP를 위반한 예시

        - ex: 동물 뽀로로 = new 펭귄();
        -> "펭귄 한 마리가 태어나 이름을 뽀로로라 하고 동물의 역할을 수행해라"
        -> 논리적으로 전혀 이상합니 없다.
        -> 즉, LSP응 지키기 위해서는 상속의 관계를 "계층도, 조직도"로 보는 것이 아닌
        분류도(벤다이어그램)으로 봐야 한다.

    하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스터스 역할을 하는 데 문제가 없어야 한다.

#### 5-4. ISP: 인터페이스 분리 원칙

    - "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다" -로버트.C.마틴

    - 앞서 단일 책임 원칙의 그림에서 "남자" 클래스는 단일 책임 원칙을 지키기 위해 하나의 역할(책임)을 가지는 다수의 클래스로 분할 되었다. 이 때, 남자를 토막 내는 것이 너무 잔인하다고 생각이 든다면, 그 때 선택할 수 있는 방법이 바로 ISP이다.

![image](<../assets/ISP(1).jpeg>) - ISP를 적용한 남자 클래스

    - 남자 클래스를 토막 내는 것이 아닌 "다중 인격화" 시켜서, "여자친구"를 만날 때에는 "남자친구"의 역할, 어머니를 만날 때에는 "아들"의 역할, "직장상사"를 만날 때에는 "사원"의 역할, "소대장"을 만날 때에는 "소대원"의 역할을 할 수 있도록 인터페이스로 제한하는 것이 "인터페이스 분할 원칙(ISP)의 핵심이다."

    - 결론적으로 SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책.

    - 소프트웨어를 설계할 때, 특별한 경우가 아니라면 SRP 원칙을 적용하는 것이 더 좋은 해결책.

    - 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드를 제공하는 것이 좋다.(인터페이스 최소주의 원칙) -> "남자친구" 인터페이스에 "사격하기" 메서드를 굳이 제공할 필요도 없고, 제공해서도 안되는 이치.

    - 상위 클래스는 풍부할수록 좋고, 인터페이스는 빈약할수록 좋다(복습. 중요중요)

    - "자기 자신을 소개하다"라는 메서드는 "남자친구" 클래스에서도 사용을 해야할 수도 있고, "사원" 클래스에서도 사용할 수도 있다. -> 그런데 남자친구 클래스에서의 "소개" 메서드와 사원 클래스에서의 "소개" 메서드는 그 역할과 기능이 달라야 한다.(남자친구 클래스에서 소개를 하는데 본인을 "저는 사원입니다."로 소개하면 안되는 원리)
    -> 그렇다면 해결책은? -> "소개" 메서드를 추상메서드 선언하여, 인터페이스를 구현해야하는 클래스에서 구현하도록 한다.

#### 5-5. DIP: 의존 역전 원칙

    - "고차원 모듈은 저차원 모듈을 의존하면 안된다. 이 두 모듈 모두 다른 추상화 된 것에 의존해야 한다." "추상화 된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화 된 것에 의존해야 한다." "자주 변경되는 구현체 클래스에 의존하지 마라" -로버트.C.마틴

    - "스노우타이어"에 의존하는 "자동차"가 있다고 가정
        - 자동차는 몇 년에 한 번 바꾸면 될 정도로 변경이 적다. 하지만 스노우타이어는
        계절이 바뀌면 일반 타이어로 교체해야 할 정도로 변경이 상대적으로 많다.
        - 이는 잘못된 설계이며, 자동차가 자신보다 더 자주 변하는 스노우타이어에
        의존하기에 부서지기 쉬운 설계이다.(냄새나는 설계)
        - 이를 좋은 향기가 나도록 개선해보면 다음과 같다.
        - 자동차가 "타이어"라는 인터페이스에만 의존하게 하고, "타이어" 인터페이스는
        스노우타이어, 일반타이어, 광폭타이어 등, 여려 구현체 타이어가 들어설 수 있다.
        - 이는 곧 개방 폐쇄 원칙(OCP)와 비슷한 해결 방식.

    - 기존에는 스노우타이어가 그 무엇에도 의존하지 않는 클래스였지만, 개선된 설계에서 스노우타이어는 "타이어" 인터페이스에 의존하게 됨. -> "의존 방향의 역전"

    - 자동차는 자신보다 변하기 쉬운 스노우타이어에 의존하던 관계를 중간에 추상화된 "타이어" 인터페이스를 추가함으로써 의존 관계의 역전이 일어남.

    - 자신보다 변하기 쉬운 것에 의존하던 것을 "추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것" -> ***의존 역전 원칙***

    - 자신보다 변하기 쉬운 것에 의존하지 마라!!
