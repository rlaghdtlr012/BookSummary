## 3. 자바와 객체 지향

#### 3-1. 객체 지향은 인간 지향이다.

    - 객체 지형은 현실 세계를 반영한다. 그 증거는? -> "객체"

    - 기존 절차적/ 구조적 프로그래밍 언어에서 가장 중요한 것은 "함수" -> 함수는 코드를 코드를 논리적인 단위로 구분하고 분할해서 정복하자는 뜻. D&C(Divide And Conquer) == 분할 정복. "천 리 길도 한 걸음부터"와 비슷한 맥락. 몇 천, 몇 만 라인의 명령어를 논리적인 단위로 나누어서 블록화해서 작성하자. 이런 논리적인 단위의 블록 -> 함수

    - 객체 지향 프로그래밍: 우주 만물은 객체들의 합이라는 거셍서부터 시작. 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍하는 방법. 따라서 직관적이다.

    - 객체 지향을 이해하기 위한 큰 그림
        - 세상에 존재하는 모든 것은 사물, 즉, 객체다.
        - 각각의 사물은 고유하다
        - 사물은 속성을 갖는다.
        - 사물은 행위를 한다

    - 사물을 하나하나 이해하기 보다는 사물을 분류(class)해서 이해하는 것이 인간의 인지법.
        - 직립보행을 하며 말을 하는 존재를 사람이라고 분류한다.
        - 연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류한다.
        - 밤하늘에 반짝이는 사물들을 별이라고 분류한다.

    - 클래스 vs 객체
        - 클래스는 객체들의 공통 특징들을 모아서 정의한 것.
        - 사람이라는 클래스가 가지는 속성으로는 나이, 몸무게, 키 등이 있으며
        이를 property라고 한다.
        - 사람이라는 클래스가 가지는 행위로는 먹다, 자다, 울다 등이 있는데,
        이를 method라고 한다.
        - 객체는 클래스의 특징을 가지고 있는 하나의 고유한 사물이다
        - 사람 클래스의 특징을 모두 가지는 "김종민"이라는 객체가 있다고 가정해보자.
        - 김종민 씨는 사람 클래스를 가지는 객체이기에 김종민씨 고유의 나이, 몸무게,
        키 속성을 가진다. 또한 김종민씨 고유의 메서드(먹고, 자고, 우는 행위 등)을
        가질 것이다.

#### 3-2. 객체 지향의 4대 특성 - 캡! 상추다

    - 객체 지향의 4대 특성: 캡! 상추다
    - 캡 -> 캡슗화(Encapsulation): 정보 은닉
    - 상 -> 상속(Inheritance): 재사용
    - 추 -> 추상화(Abstraction): 모델링
    - 다 -> 다형성(Polymorphism): 사용 편의

#### 3-3. 클래스 vs 객체 == 붕어빵틀 vs 붕어빵 -> 사실 잘못된 비유다?

    - 객체 지향을 배울 때, 가장 흔한 예로 드는 것이 바로 클래스와 객체의 관계를 붕어빵틀과 붕어빵이다.

```java
클래스 객체명 = new 클래스();
```

    - 그런데 이는 사실 정확한 비유가 아니다. 추가로 예시를 들기 위해 붕어빵틀을 생산하는 금형 기계가 있다고 하자. 그럼 붕어빵틀이 붕어빵을 찍어내서 클래스라고 한다면, 같은 논리로 금형 기계는 붕어빵틀을 찍어내는 클래스가 된다. 이를 코드로 나타내면

```java
금형기계 붕어빵틀 = new 금형기계();
```

    - 위 코드를 인간의 말로 번역해보면 "새로운 금형기계를 하나 만들었더니 붕어빵틀이다"이다. 이는 절대 금형기계와 붕어빵틀이 클래스와 객체 관계가 아니듯이 붕어빵틀과 붕어빵도 클래스와 객체 관계가 아닌 것이다.

    - 그렇다면 객체와 클래스를 가장 잘 구분할 수 있는 기준은 무엇일까? 다음 질문의 답을 해보자

    - 사람의 나이는 몇 살인가?
    - 김연아의 나이는 몇 살인가?
    - 뽀로로의 나이는 몇 살인가?
    - 펭귄의 나이는 몇 살인가?

    - 사람과 펭귄의 나이를 맞출 수는 없다. 왜녀하면 클래스는 분류에 대한 개념일 뿐, 실체가 아니기 때문이다

    - 객체는 실체이다.

    - 따라서 붕어빵틀과 붕어빵이라는 잘못된 예시(왜냐하면 붕어빵틀은 분명히 실체가 존재하기 때문?) 대신 올바른 메타포는 다음과 같다

```java.. ㅊ
ㅕ7
클래스 : 객체 = 펭궨 : 뽀로로 = 사람 : 김연아
```

    클래스: 분류에 대한 개념. 실체가 아님
    객체: 클래스의 특징을 가지고 있는 확실한 실체 그 자체

#### 3-4. 추상화(Abstraction) == 모델링

    - 객체 지향에서의 추상화: 공통 특성 / 공통 속성 추출

    - 객체 지향에서의 추상화는 곧 모델링이다.

    - 사람이라는 클래스를 설계한다고 가정해보자
        - 사람 클래스의 속성으로는 시력, 몸무게, 혈액형, 키, 나이, 직업, 취미
        등등의 속성을 가진다.
        - 먹다, 자다, 일하다, 침 뱉다, 울다 등등의 동사로 표현되는 특성을
        기능/ 행위라고 한다. 이러한 기능 / 행위를 메서드라고 한다.

    - IT 용어에서의 추상화: 구체적인 것을 분해해서 관심 영역(애플리케이션 경계.Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링

    - 추상화의 대표적인 예시: 지구 - 지구본의 관계. 지구본에 지구의 모든 요소를 표현할 수는 없지만, 지구의 대표 속성인 바다, 대륙 등을 이용하여 지구의 특성을 추상화 하였다.

    - 객체 지향에서 추상화의 결과는 클래스이다.

    - 추상화는 상속, 인터페이스, 다형성을 통해 구현될 수 있다.

    - 추상화 = 모델링 = 자바의 class 키워드

#### 3-5. 상속: 재사용 + 확장

    - 객체 지향에서의 상속을 현실에서의 상속(Inheritance)의 개념으로 이해하면 안된다.

![image](<../assets/inheritance(1).jpeg>) - 상속에 대한 잘못된 예시
<br><br><br><br>

![image](<../assets/inheritance(2).jpeg>) - 상속에 대한 올바른 예시

    - 객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래서에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미

    - 상위 클래스(슈퍼 클래스)로 갈수록 추상화, 일반화 됐다라고 말할 수 있으며, 하위 클래스(서브 클래스)로 갈수록 구체화, 특수화 됐다라고 말할 수 있다.

    - 상속 관계에서 "하위 클래스는 상위 클래스다"라는 명제는 반드시 만족해야 하는 명제이다.

    - 객체를 생성할 때, 객체 참조 변수명은 객체스럽게, 클래스명은 클래스명답게 작명하는 습관이 중요하다.

    - ex: 조류 bird = new 조류(); -> 매우 좋지 않은 코드
        - 왜냐하면 "bird"에 해당하는 부분은 객체 참조 변수인데, 객체 참조 변수는 그
        자체로 하나의 개체이자 유일무이한 것이기 때문이다. bird의 나이는?
        bird의 무게는? bird를 실체를 가지는 하나의 객체로 만들어줬음에도 불구하고
        해당 질문에 대한 답을 할 수가 없다.
        따라서 객체를 만들 때에는 객체명을 유일무이하게 구분 가능하게 지어야한다.

    - 상속 관계를 표현하는 문구는 "is a"보다는 "is a kind of"라는 문구가 더 정확하다.

    - 객체 지향의 상속은 상위 클래스의 특성을 재사용 하는 것

    - 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것

    - 객체 지향의 상속은 is kind of 관계를 만족해야 함

    - 자바에서의 인터페이스
        - 인터페이스: 구현 클래스 is able to 인터페이스
        - 구현 클래스는 인터페이스 할 수 있다
        - ex: 고래는 헤엄칠 수 있다.

    - 상위 클래스는 하위 클래스에게 특성(속성 + 메서드)를 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라는 기능을 구현하도록 강제하도록 한다.

    - 상위 클래스는 하위 클래스에서 물려줄 특성이 풍부할수로 좋다.

    - 상위 인터페이스는 구현을 강제할 메서드가 적을수록 좋다.

#### 3-6. 다형성: 상속 편의성

    - 기본적으로 객체 지향에서의 다형성: 오버라이딩(overriding), 오버로딩(overloading)

    - 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
    - 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

    - 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고, 이러한 다형성이 개발자가 프로그램을 작성할 때 사용 편의성을 줌

#### 3-7. 캡슐화: 정보 은닉

    - 접근 제어자: private, default, protected, public

    - 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후, 객체 잠조 변수를 이용해 접근해야 한다.

    - 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장(일관된 형식으로 접근 및 메모리의 물리적 접근에 따른 이유)

    - protected에 대한 오해와 진실: protected는 같은 패키지 내의 모든 클래스에서 접근이 가능하다? -> No!

    -aaa.jar 파일 안에 packageOne이라는 패키지가 있고, bbb.jar 파일 안에도 packageOne이라는 같은 이름을 가진 패키지가 있다고 가정해보자.

    - bbb.jar 파일 내부의 packageOne 패키지 내 클래스나 객체에서 aaa.jar 파일 내부의 packageOne 패키지 내 클래스나 객체가 가진 public 멤버 뿐만 아니라 default, protected 멤버에 자유롭게 접근할 수 있다...
