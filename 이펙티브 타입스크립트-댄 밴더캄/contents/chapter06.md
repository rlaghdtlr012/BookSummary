## 6장. 타입 선언과 @types

### 아이템 45: devDependency에 typescript와 @types 추가하기

- npm은 세가지 종류의 의존성을 구분해서 관리. 각각의 의존성은 package.json 파일 내의 별도 영역에 존재

- dependencies
  - 현재 프로젝트를 실행하는 데 필수적인 라이브러리들 포함
  - 프로젝트 설치시, 라이브러리도 같이 설치
  - 전이(transitive) 의존성
- devDependencies
  - 개발 및 테스트하는데 사용, 하지만 런타임에는 필요없는 라이브러리들
  - 프로젝트 설치시, devDependencies에 있는 라이브러리들은 제외됨
- peerDependencies

  - 런타임에 필요하긴 하지만 의존성을 직접 관리하지 않는 라이브러리들
  - ex: 플러그인

- 타입스크립트 프로젝트에서 공통적으로 고려해야 할 부분
  - 팀원들 간의 버전 차이 등의 문제로 **ts를 시스템 레벨로 설치하기보다는 devDependencies에 넣는 것이 좋음**
  - 타입 의존성(@types)도 고려해야 함
    - @types에 여러 라이브러리에 대한 타입이 정의되어 있음
    - 다만 타입 정보만 있을 뿐, 구현체는 포함되지 않음
- 원본 라이브러리는 dependencies에 있더라도 @types 의존성은 devDependencies에 있어야 함.

### 아이템 46: 타입 선언과 관련된 세 가지 버전 이해하기

- 타입스크립트를 사용하면 의존성 관리가 더 복잡해짐. 왜냐하면 타입스크립트를 사용하면 다음 세가지 사항을 추가로 고려해야 하기 때문

  - 라이브러리 버전
  - 타입 선언(@types)의 버전
  - 타입스크립트 버전

- 즉, 타입스크립트 그 자체, 라이브러리, 라이브러리 타입의 버전. 이 세 가지의 종류의 패치 정보들에 대해서 고려를 해야함.
- 그리고, dependencies에 저장됨 라이브러리의 버전과 devDependencies에 저장된 타입에 대한 버전이 보통 일치하지 않음. (보통 타입에 대한 패치가 더 많이 이루어짐)

  - ex: react@16.8.6, @types/react@16.8.19

- 라이브러리와 타입 정보의 버전을 따로 관리할 때의 문제점

  - 첫 번째, 라이브러리는 업데이트했지만, 실수로 타입 선언은 업데이트 하지 않은 경우. 타입 오류 발생. 만약 하위 호환성이 깨지는 변경이 있었다면, 타입 체커를 통과하더라도, 런타임에서 오류 발생. 만약 타입 버전이 원본 라이브러리 버전을 따라오지 못하는 경우 -> 보강(augmentation)을 사용하여 타입 정보를 추가해주는 방법이 있음
  - 두 번째, 라이브러리보다 타입 선언의 버전이 최신인 경우. 타입 체커는 최신 api를 기준으로 코드를 검사하지만, 실제 런타임에 쓰이는 것은 과거 버전. 해결책: 라이브러리의 버전을 올리거나 타입의 버전을 내림
  - 세 번째, 타입스크립트 자체 버전보다, 라이브러리에서 사용하는 타입스크립트 버전이 높은 경우. 일반적으로 lodash, react, ramda 등의 유명 라이브러리는 버전이 올라갈 때마다 그 안에 있는 타입스크립트 버전도 같이 올라간다. 이 경우, @types 선언 자체에서 타입 오류 발생.
    해결책: ts 버전 올리거나, 라이브러리 버전을 내리거나, **declare module 선언으로 라이브러리 타입 정보를 없앤다.**

  - 공식적인 권장사항: 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함
  - 라이브러리를 업에이트 할 경우, @types도 같이 업데이트 하는 것이 좋음

### 아이템 47: 공개 API에 등장하는 모든 타입을 익스포트 하기

- 라이브러리를 공개적으로 만들 경우, 어떤 경우의 타입이든 익스포트 합시다.
- 그렇지 않으면 라이브러리 사용자가 별도로 타입을 추출해야 하는 번거로운 작업을 해야함

### 아이템 48: API 주석에 TSDoc 사용하기

- 사용자를 위해서 주석을 // 형식이 아닌 /\*\* \*/ 형식의 JSDoc 스타일로 주석을 작성하는 것이 좋음
- 왜냐하면 JSDoc 스타일로 주석을 작성하면, 편집기에서 함수가 호출되는 곳에서 JSDoc에서 작성한 주석을 툴팁으로 표시해주기 때문(// 인라인 주석은 편집기가 주석을 툴팁으로 표시해주지 않음)
- 타입스크립트가 JSDoc 스타일을 지원해주기 때문에 JSDoc을 사용해서 주속을 작성하는 것을 적극 활용하자

- 예시

  ```typescript
  /**
   * 인사말을 생성합니다
   @param name 인사할 사람의 이름
   @param title 그 사람의 칭호
   @returns 사람이 보기 좋은 형태의 인사말
   */
  function gettFullTSDoc(name: string, title: string) {
    return `Hello ${title} ${name}`;
  }
  ```

- 자바스크립트를 사용하면 {타입}을 사용하여 각 요소에 대한 타입도 정의해 줄 수 있지만, **타입스크립트는 코드에 타입 정보가 있기 때문에 TSDoc에서는 타입 정보를 명시하면 안됨(출근해서 주석 수정해야겠다..)**

### 아이템 49: 콜백에서 this에 대한 타입 제공하기

- this는 전형적으로 객체의 현재 인스턴스를 참조하는 클래스에서 가장 많이 사용됨

- 자바스크립트에서 this 바인딩을 온전히 제어할 수 있는 방법
  - call을 사용
    ```typescript
    const c = new C();
    const method = c.logSquares;
    method.call(c); // call을 이용한 this qkdlseld
    ```
- 타입스크립트의 콜백 함수에서 this를 사용하는 경우라면
  - 콜백 함수의 매개변수에 this를 추가하고, 콜백 함수를 call로 호출해서 해결할 수 있음
- 콜백함수에서 this를 사용하면, this는 API의 일부가 되는 것이기 때문에 반드시 타입 선언에 포함해야 함.

### 아이템 50: 오버로딩 타입보다는 조건부 타입을 사용하기

- 타입스크립트에서 구현체는 하나지만, 타입 선언은 몇 개든 만들 수 있음

- 오버로딩 타입
  ```typescript
  function double(x: number | string): number | string;
  function double(x: any) {
    return x + x;
  }
  ```
- 조건부 타입

  ```typescript
  function double<T extends number | string>(
    x: T
  ): T extends string ? string : number;

  function double(x: any) {
    return x + x;
  }
  ```

- 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확
- 조건부 타입은 타입 체커가 각각의 타입을 단일 표현식을 받아들이기 때문에 유니온 문제를 해결 가능

### 아이템 51, 52: 어려워서 잠시 보류
