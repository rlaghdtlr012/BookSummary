## 2.1 타입이란

- 자료형으로서의 타입

  - 값을 변수에 할당할 때, 이는 메모리에 할당, 저장됨
  - 최신 ESMAScript 표준을 따르는 JS는 다음 7가지 데이터 타입(자료형)을 정의함
    - undefined
    - null
    - Boolean
    - String
    - Symbol
    - Numeric
    - Object
  - 데이터 타입은 여러 종류의 데이터를 식별하는 분류 체계
  - 컴파일러에 값의 형태를 알려줌
  - 개발자 입장에서는 타입을 사용해서 값의 종류를 명시 가능. 메모리를 효율적으로 사용 가능

- 집합으로서의 타입

  - 어떤 값이 T 타입이라면 컴파일러(혹은 개발자)가 이 값으로 어떤 일을 할 수 있고, 어떤 일을 할 수 없는지를 사전에 알 수 있다.
  - 런타임에서 발생할 수 있는 에러를 방지해 줌
    ```typescript
    // number 데이터 타입을 인자로 받아서 곱하기 2를 해주는 함수
    function double(n: number) {
      return n * 2;
    }
    double(2); // 4
    double("z"); // Error! Argument of type 'string' is not assignable to parameter if type 'number' -> 타입 에러 발생
    ```

- 정적 타입과 동적 타입

  - 자바스크립트는 기존에 변수와 값에 타입을 지정해주지 않았다 -> 실상은 개발자가 컴파일 이전에 타입을 직접 지정해주지만 않았을 뿐.
  - 타입을 정하는 시점에 따라 타입을 "정적 타입(statuc type)"과 "동적 타입(dynamic type)"으로 분류 가능
  - 정적 타입 시스템: 모든 변수의 타입이 컴파일타임에 결정됨
    - 개발자가 타입을 명시해줘야 하는 C, 자바, 타입스크립트가 그 예시.
    - 번거롭긴 하지만 컴파일 타임에 타입 에러를 발견할 수 있기 때문에 프로그램의 안정성 보장
  - 동적 타입 시스텝: 변수 타입이 런타임에서 결정됨
    - 파이썬, 자바스크립트가 그 예시. 개발자가 직접 타입을 정의해줄 필요x
    - 코드 작성이 자유롭지만 버그 났을 때, 찾기가 힘듦

- 컴파일타임과 런타임

  - _컴파일타임_: 기계가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점
  - _런타임_: 기계어로 변환된 파일이 메모리에 적재되어 실행되는 시점

- 암묵적 타입 변환: 개발자가 따로 타입을 명시해주지 않았는데도 런타임에 타입이 자동으로 변경되는 것

- 강타입과 약타입

  - 암묵적 타입 변환 여부에 따라 강타입과 약타입으로 분류 가능
  - 강타입 특징: 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러 발생(ex: 파이썬, 루비, 타입스크립트)
  - 약타입 특징: 서로 다른 타입을 갖는 값끼리 연살할 때, 컴파일러 또는 인터프리터 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후, 값 도출(ex: C++, 자바, 자바스크립트)
  - 자바스크립트는 약타입 언어이기에 런타임에서 발생하는 에러를 사전에 방지하는 코드를 짜는 것이 중요 -> 타입스크립트의 등장배경
  - 타입스크립트는 컴파일러에 어떤 타입을 사용하는지 명시적으로 알려줘야 하는 타입 시스템과 자동으로 타입을 추론하는 타입 시스템. 두 가지 모두의 영향을 받음

- 컴파일 방식
  - 컴파일: 서로 다른 수준(고수준 - 저수준) 간의 코드 변환
  - 타입스크립트의 컴파일 결과물 -> 자바스크립트 코드
  - 타입스크립트의 탄생 배경: 컴파일타입에 런타임 에러를 사전에 잡아내기 위함

## 2.2 타입스크립트의 타입 시스템

- 타입애너테이션 방식: 타입을 명시적으로 선언해서 어떤 값이 저장될 지 컴파일러에 직접 알려주는 문법.
- ex: 자바, C#

  ```java
  int woowahanNum = 2010;
  float woowahanFloatNum = 2.01f;
  ```

  ```typescript
  // 타입 스크립트는 변수 이름 뒤에 : type 구문을 통해 데이터 타입 명시
  let isDone: boolean = false;
  let color: string = "blue"
  let list: number[] - [1, 2, 3];
  ```

- 구조적 타이핑

  - 값이나 객체가 하나의 구체적인 타입을 가지고 있는 언어에서 사용되는 개념
  - 이름으로 타입을 구분하는 다른 타입 언어와 달리 ts는 구조로 타입을 구분한다. -> 구조적 타이핑

- 구조적 서브 타이핑

  - 타입은 단지 집합에 포함되는 값. 더 많은 값들이 집합에 포함될 수 있음
  - 예시로 string과 number 타입을 동시에 가질 수 있음을 의미
  - 자바는 두 클래스 내부의 멤버 변수, 메서드의 이름과 타입이 같더라도 각 클래스로부터 생성된 인스턴스는 서로 호환되지 않음. 명목적 타이핑은 (클래스) 이름으로 구분되기에 변수의 이름이 같더라도 다른 타입으로 취급됨
  - 하지만 ts는 js를 모델링한 언어.
  - 따라서 객체나 함수의 구조적 특징을 기반으로 구분함.
  - js는 덕 타이핑(duck typing: 어떤 매개변수값이 올바르게 주어진다면, 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다는 개념) 기반으로 함.

- 트리쉐이킹(tree-shaking)
  - js, ts에서 사용하지 않는 코드를 삭제하는 방식.
  - 웹팩, 롤업 등의 모듈 번들러를 작동 시, 사용하지 않는 코드는 자동으로 삭제됨.

## 2-3. 원시 타입

- js에서 값은 타입을 가지지만, 변수는 별도의 타입을 가지지 않음.
- 따라서 js의 변수는 어떤 타입이든 자유롭게 할당할 수 있음.
- ts는 변수에도 타입을 지정하는 타입 시스템 체계를 구축.
- ts에서 특정 타입을 지정한 변수에 해당 타입의 값만 할당 가능
- js에서의 7가지 원시 값은 ts에서 원시 타입으로 존재함.
  <br><br>

- boolean

  - true, false 값만 할당할 수 있는 boolean 타입

- undefined

  - 정의되지 않았다는 의미의 타입. 오직 undefined 값만 할당할 수 있음
  - 일반적으로 초기화 되지 않은 값을 의미. 변수 선언만 하고 값을 할당하지 않은 경우 undefined.
  - 초기화되지 않았거나 존재하지 않음

- null

  - 오직 null만 할당할 수 있음.
  - js에서 보통 빈 값을 할당해야 할 때, null을 사용
  - 명시적, 의도적으로 값이 아직 비어있을 수 있음을 보여줌

- null vs undefined

  ```javascript
  // Person1은 사람마다 job이라는 속성이 있을 수도 있고 없을 수도 있음을 나타냄
  // 즉, job이라는 속성 유무를 통해 무직인지 아닌지 판단
  type Person1 = {
    name: string,
    job?: string,
  };

  // Person2는 사람마다 job이라는 속성은 가지고 있지만, 그 값이 null 일 수도 있음을 나타냄
  // 즉, 명시적인 null 값을 할당해 무직인 상태를 나타냄.
  type Person2 = {
    name: string,
    job: string | null,
  };
  ```

- number

  - 정수, 부동소수점수 등을 모두 number 타입으로 할당 가능
  - js의 원시 숫자값 중 NaN, Infinity도 포함됨.

- bigInt

  - ts 3.2 버전부터 사용가능
  - 2^53 - 1 이상의 큰 수를 처리 가능
  - number와 bigInt 타입은 엄연히 서로 다른 타입이기에 상호 작용은 불가능

- string

  - 문자열 할당 가능.
  - 작음 따옴표, 큰 따옴표, 백틱(``: 템플릿 리터럴) 등에 해당

- symbol
  - Symbol 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값 생성 가능

```typescript
const MOVIE_TITLE = Symbol("title");
const MUSIC_TITLE = Symbol("title");
console.log(MOVIE_TITLE === MUSIC_TITLE); // false
// 같은 title이라는 동일한 문자열을 넘겨줬음에도 불구하고 서로 다른 값을 가지고 있음
```

- 일반적으로 ! 연산자를 이용한 타입 단언 방법 보다는 타입 가드를 사용하는 것이 더 안전하다고 여겨짐

## 2-4. 객체 타입

- 2.3의 7가지 원시 타입에 속하지 않는 값을 모두 객체 타입으로 분류
- ts는 다양한 형태를 가지는 객체마다 개별적으로 타입 지정 가능
- 매우 복잡한 구조를 가진 객체도 타입으로 만들어 관리할 수 있음

- object

  - Object 타입은 가급적 사용하지 말도록 권장됨.(any 타입과 유사하게 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어서 정적 타이핑의 의미가 퇴색되기 때문)

- 중괄호 {}

  - 중괄호는 js에서 객체 리터럴(객체를 만드는 표기법) 방식으로 객체를 생성할 때 사용
  - ts에서는 중괄호 안에 객체의 속성 타입을 지정해주는 식으로 사용
  - ts에서 {} 타입으로 지정된 객체는 어떤 값도 속성으로 할당할 수 없음

- array

  - 배열, 함수, 정규식 등도 객체 범주에 속함
  - ts에서의 배열은 array라는 별도 타입으로 다룬다.
  - ts 배열 타입은 하나의 타입 값만 가질 수 있음에 js의 배열보다 엄격함
  - Array 키워드로 선언 or []로 선언

- type과 interface 키워드

  - 실무에서는 object 타입을 잘 사용하지 않음
  - 흔히 객체를 타이핑하기 위해 자주 사용되는 키워드로 "type"과 "interface"가 있다.
  - 다음과 같이 타입 선언시, 반복적으로 사용돼도 중복 없이 해당 타입 사용 가능

    ```typescript
    type NoticePopupType = {
        title: string;
        description: string;
    };

    interface INoticePopup {
        title: string;
        description: string;
    }

    const noticePopup1 = NoticePopupType = {...};
    const noticePopup2 = INoticePopup = {...};
    ```

  - 일반적으로 타입스크립트 컴파일러는 변수 사용 방식과 할당된 값의 타입을 분석해서 타입을 유추한다. 따라서 모든 타입을 일일이 명시적으로 선언할 필요는 없음.

- function

  - js에서는 함수도 일종의 객체로 간주. 하지만 function 타입이라는 별도의 타입이 있음
  - 허나 js에서는 function이라는 키워드 자체를 타입으로 사용하지 않음.
  - 대신 매개변수 및 반환값에 대한 타이핑이 필요
  - 함수 자체에 대한 타입 지정은 "호출 시그니처"를 정의하는 방식을 사용.

- 호출 시그니처(call signature) - ts에서 함수 타입을 정의할 때 사용하는 문법 - 함수의 매개변수와 반환값의 타입을 명시하는 역할
  `typescript
    type add = (a: number, b: number) => number;
    // js의 화살표 함수와 유사하나, js에서 함수 작성시, function 키워드를 사용하는 것과 다르게 ts에서의 호출 시그니처는 오로지 화살표 함수 방식으로만 호출 시그니처를 정의한다.
    `
  <br>

### 우형에서의 type과 interface 키워드 사용

- A팀: 대부분 interface 사용. 간단한 용도로 type 사용. 전역적으로 사용할 때에는 interface, 작은 범위 내에서 한정적으로 사용한다면 type. 객체 지향적으로 코드를 짤 때, 상송하는 경우(extends)에 interface 사용
- B팀: 둘 다 사용. type은 어떤 값에 대한 정의 같이 정적으로 경정되어 있는 것에, interface는 확장될 수 있는 basis를 정의하거나 어떤 object 구성을 설명하는 요소. 유니온 타입이나 교차 타입 등, type에서만 쓸 수 있는 기능을 활용할 때, type 사용. interface는 서로 다른 컴포넌트끼리 같은 속성을 공유하는 "기준 인터페이스"를 정의하고 확장할 때 사용
- C팀: 병합이 필요할 때는 interface, computed value를 사용해야 한다면 type 정의.
- D팀: 주로 type을 사용. IDE에서 디버깅 시, interface는 인터페이스 이름만 노출되고, type은 리터럴한 값이 직접 노출되어 type 사용 시, 더 쉽게 타입 추론 가능. computed value를 써야했을 때 type 정의를 사용함
  <br><br><br>

- computed value?

  - 객체의 특정 속성 값이 계산되어 하는 경우를 의미함
  - 일반적으로 TypeScript에서 타입(Type)은 객체의 모양(shape)을 정의하거나 다양한 타입을 조합하는 데 사용됨. 그러나 때로는 특정 속성의 값이 동적으로 계산되는 경우가 있는데 이런 경우에 타입을 사용하여 해당 계산된 값을 명시할 수 있다.

    ```typescript
    // 타입 정의
    type Circle = {
      radius: number;
      area: number; // 계산된 값의 타입 정의
    };

    // 함수를 통해 Circle 객체 생성
    function createCircle(radius: number): Circle {
      const area = Math.PI * radius * radius;
      return { radius, area };
    }

    // Circle 타입을 사용한 객체 생성
    const myCircle: Circle = createCircle(5);

    console.log(myCircle.radius); // 5
    console.log(myCircle.area); // 계산된 값
    ```

  - 위의 코드에서 Circle 타입은 radius와 area라는 두 속성을 가지고 있다. area는 radius를 기반으로 계산된 값. 함수 createCircle를 통해 Circle 타입의 객체를 생성하면, area 속성은 radius 값에 따라 동적으로 계산됩니다. 이때 Circle 타입을 사용하여 area 값의 타입도 정의되어 있다.
  - 이런 식으로 TypeScript는 객체의 특정 속성 값이 계산되어야 하는 경우, 해당 계산된 값을 명시하기 위해 type 키워드을 사용할 수 있다.
